# 자바와 절차적/구조적 프로그래밍

## 자바 프로그램의 개발과 구동 

### JDK, JRE, JVM
| 이름  | 설명                                            |
|-----|-----------------------------------------------|
| JDK | 자바 개발 도구, JVM용 개발 소프트웨어, javac.exe(자바 소스 컴파일러) |
| JRE | 자바 실행 환경, JVM용 OS, java.exe(자바 프로그램 실행기)      |
| JVM | 자바 가상 기계, 가상의 컴퓨터                             |

Java 프로그램은 운영체제 비종속적이다 → **JVM이 각 운영체제에서 문제 없이 작동할 수 있도록 만들어준다.**

### 객체지향 프로그램의 메모리 사용 방식  
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F9988E33359A771AB09B623)   
[이미지 출처](https://lktprogrammer.tistory.com/1)

**주의) 운영체제의 메모리(코드, 데이터, 힙, 스택)와 객체지향 프로그램 메모리 사용방식은 서로 관련이 없다!!**

## 자바에 존재하는 절차적/구조적 프로그램밍의 유산
* **절차적 프로그래밍**   
  * goto 사용 금지

* **구조적 프로그래밍**   
  * 함수 사용
    * 중복 코드 제거
    * 논리 분할
  * 지역 변수 사용 


## main()
**Static 영역 - 클래스, Stack 영역 - 메서드, Heap 영역 - 객체**

```
public class Start  {
    public static void main(String[] args) {
        System.out.println("Hello OOP!");
    }
}
```
>1. JRE는 프로그램안에 main() 메서드가 있는지 확인
>2. JVM의 전처리
>   * java.lang 패키지를 static 영역에 놓는다.
>   * 모든 클래스와 임포토 패키지를 static 영역에 놓는다.
>3. Stack 영역에 main()의 stack frame이 할당된다.
>4. main()의 인자 args를 저장할 변수 공간을 stack frame에 맨밑에 확보
>5. main()이 끝난 후 Stack 영역에 main()의 stack frame이 소멸된다.
>6. 메모리 소멸
>7. JVM 가동 중지
>8. JRE가 사용했던 시스템 자원을 운영체제에 반환

** main() 메서드는 프로그램의 시작이자 끝이다!**

## 변수와 메모리
```
public class Start  {
    public static void main(String[] args) {
        int i;
        i = 10;
    }
}
```
>_1 ~ 4 는 이전 main()에서의 설명과 동일_  
>5. i 변수 공간이 args 변수 공간 위에 확보(**Stack**)
>   * 변수 공간은 초기화 되지 않았기 때문에 쓰레기 값이 들어가 있다.
>6. i 변수 공간에 10을 할당 
>7. main()이 끝난 후 Stack 영역에 main()의 stack frame이 소멸된다.
>8. 메모리 소멸
>9. JVM 가동 중지
>10. JRE가 사용했던 시스템 자원을 운영체제에 반환

```int i = 10```은 선언과 초기화를 한번에 한 것일 뿐 1)변수 공간 확보, 2) 변수 공간에 값 할당의 단계는 동일하다.

## 블록 스택 프레임
```
// main() 안에 아래와 같은 코드가 있다고 가정
int i = 10;
int k = 20;

if(i == 10 ) {
  int m = k + 5;
  k = m;
}else{
  int p = k + 10;
  k = p;
}
```
위와 같은 상황에서 main() 메서드의 스택 프레임안에 if 문의 블록 스택 프레임이 생성된다.   
그리고 블록 스택 프레임 내부에 변수 m에 공간과 값이 할당 된다.

## 지역 변수와 메모리
| Static                   | Stack                  | Heap                     |
|--------------------------|------------------------|--------------------------|
| 클래스                      | 메서드                    | 객체                       |
| 클래스 멤버 변수, JVM이 종료되면 소멸  | 지역 변수, 스택 프레임이 사라지면 소멸 | 객체 멤버 변수, 가비지 컬렉터에 의해 소멸 |


**외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 내부 스텍 프레임에서 외부 스택 프레임의 변수에 접근하는 것은 가능하다.**

## 메서드 호출과 메모리 
```
public class Start {
  public static void main(String[] args) {
    int k = 5;
    int m;
    
    m = square(k);
  }
  
  private static int square(int k) {
    int result;
    .
    .
    .
    return result;
  }
}
```
Stack 영역 내에 main() 스택 프레임 위에 square() 스택 프레임이 생성된다. 그리고 square() 스택 프레임 내부에
반환 값 저장 공간과 k, result에 대한 변수 공간이 차례로 생성된다.

```
----[ squre() ]----
      result
        k
      반환 값
------------------- 
```

**메서드 스택 프레임들은 서로의 지역 변수에 직접 접근할 수 있는 방법은 없다!  
메서드 사이에서 값을 전달하는 방법은 메서드의 인자와 반환값을 이용해 전달하는 Call By Value 뿐이다.**

## 전역 변수와 메모리
```
public class Start5 {
  static int share; // 전역 변수
  
  public static void main(String[] args) {
    share = 55;
    .
    .
    .
  }
}
```

변수 share는 class가 메모리 Static 영역에 배치될 때 class 내부에 클래스의 멤버로 공간을 만들어 저장된다.

>지역 변수: 스택 프레임에 종속적   
>전역 변수: 스택 프레임에 독립적

**전역 변수는 코드가 복잡해지면 저장돼어 있는 것을 파악하기가 쉽지 않기에 사용이 지양된다.**

## 멀티 스레드 / 멀티 프로세스
### 멀티 스레드
* 메모리의 스택 영역을 스레드 개수만큼 분할 해서 사용한다.(스택 영역만 분할하고 힙과 스태틱 영역은 공유한다.)
* 메모리를 적게 사용할 수 있다. → 좀 더 효율적이다.
* 멀티 스레드 상황에서 전역 변수를 사용할 경우 마지막으로 접근한 스레드에 의해 값이 결정된다.
  * 락을 걸어 해결할 수 있으나 스레드의 장점이 사라져 버린다.
  * synchronizeed는 자바의 예약어로 thread-safe를 구현할 수 있다.


### 멀티 프로세스
* 다수의 메모리를 가진다.(프로세스마다 각자의 메모리가 있다)
* 안정성은 좋으나 메모리 사용이 많다.